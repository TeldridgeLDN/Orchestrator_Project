---
rule_version: 1.0.0
last_updated: 2025-11-18
authoritative_source: Orchestrator_Project
---

# Context Efficiency - Universal Token Economy

**Priority:** Critical  
**Applies To:** All diet103 projects  
**AI Assistants:** Claude, Cursor, Windsurf, Cline, Roo, and all others

---

## Core Principle

**Every byte of context loaded must provide immediate value. Token efficiency is not optional.**

This rule extends beyond documentation (covered by Documentation Economy) to encompass ALL text generation: code, comments, variable names, test descriptions, and file structures.

---

## Relationship to Existing Rules

**Complements:**
- **Documentation Economy** (governs markdown files specifically)
- **File Lifecycle** (governs file retention, this governs file creation)
- **Rule Integrity** (provides conflict resolution framework)

**Extends:** diet103's 500-line rule from principle to formalized primacy rule

**Conflicts With:** None identified

---

## Why This Matters

### The Token Economy Crisis

**Problem:** AI assistants operate with limited context windows. Every unnecessary token:
- Reduces space for valuable information
- Increases API costs
- Slows response times
- Creates cognitive overhead

**diet103 Philosophy:**
> "Token Efficiency Above All - Every byte of context loaded should provide immediate value."

**Current Coverage Gaps:**
- Documentation Economy: ✓ Covers markdown documentation
- File Lifecycle: ✓ Covers file retention
- **MISSING:** Code comments, variable names, test verbosity, file sizes

This rule fills that gap.

---

## The 500-Line Rule (Formalized)

### Core Mandate

**All files MUST be under 500 lines.**

This is diet103's foundational principle, now formalized as an Orchestrator primacy rule.

**Why 500 Lines?**
- Fits comfortably in AI context window
- Forces modular thinking
- Enables progressive disclosure
- Prevents monolithic files

### Implementation

#### For New Files

```markdown
✅ DO: Create file, monitor line count
    If approaching 500 lines → Split proactively

❌ DON'T: Create 1000-line file, promise to "refactor later"
```

#### For Existing Files

```bash
# Audit current files
find . -name "*.js" -o -name "*.ts" -o -name "*.md" | \
  xargs wc -l | \
  awk '$1 > 500 {print $1, $2}'

# Split oversized files using progressive disclosure
```

#### Exceptions

**Allowed Exceptions (Must Be Justified):**

1. **Generated Files** (Auto-generated code)
   - Example: Prisma client, OpenAPI specs
   - Justification: Not hand-maintained, rarely read in full
   - Limit: < 2000 lines (split if larger)

2. **Data Files** (JSON, YAML configuration)
   - Example: Package-lock.json, large configs
   - Justification: Machine-readable, not for human context
   - Limit: No specific limit, but avoid loading into context

3. **Legacy Migration** (Temporary during refactor)
   - Example: Old 2000-line file being split
   - Justification: Work in progress
   - Deadline: Must complete within 2 weeks

**Override Protocol:**
```markdown
## File: src/generated/api-client.ts (847 lines)

**Exception Type:** Generated File
**Justification:** Auto-generated by OpenAPI, updated by CI/CD
**Review Date:** 2026-01-01 (check if generator improved)
**Mitigation:** Never load full file, use symbol navigation
```

---

## Progressive Disclosure Pattern

### The Three-Layer Model

**Layer 1: Metadata (Always Loaded)**
- File/skill purpose (1-2 sentences)
- Public API surface
- Usage examples (minimal)
- < 50 lines

**Layer 2: Implementation (Load on Demand)**
- Core logic
- Primary functions
- < 500 lines

**Layer 3: Details (Load When Needed)**
- Edge cases
- Extensive examples
- Troubleshooting
- Resources
- Each < 500 lines

### Example: Skill Structure

```
.claude/skills/shopify-integration/
├── SKILL.md (Layer 1: 45 lines)
│   ├── Purpose: "Manage Shopify store integration"
│   ├── Commands: list, brief descriptions
│   └── Quick start example
│
├── implementation/ (Layer 2)
│   ├── setup.md (380 lines)
│   ├── products.md (420 lines)
│   └── orders.md (395 lines)
│
└── resources/ (Layer 3)
    ├── api-reference.md (450 lines)
    ├── troubleshooting.md (320 lines)
    └── examples.md (480 lines)
```

**Loading Strategy:**
```
User asks: "How do I set up Shopify?"
  ↓
Load: SKILL.md (45 lines) ✓
  ↓
User needs details: "Show me authentication setup"
  ↓
Load: implementation/setup.md (380 lines) ✓
  ↓
Total context: 425 lines (vs 2045 lines if loaded all)
```

---

## Code Comment Economy

### Guiding Principle

**Comments should explain WHY, not WHAT. The code itself should explain WHAT.**

### Comment Verbosity Guidelines

#### ✅ GOOD: Concise, High-Value Comments

```javascript
// Prevent race condition in auth token refresh
const lock = new Mutex();

// Retry 3x for network failures (API rate limit = 5 req/sec)
const maxRetries = 3;

// Cache expires after 1h (security requirement)
const cacheExpiry = 3600;
```

**Characteristics:**
- 1 line per comment
- Explains non-obvious WHY
- Provides essential context
- Total: ~50 tokens

#### ❌ BAD: Verbose, Low-Value Comments

```javascript
/**
 * This function handles authentication which is important because
 * users need to log in to access the system. It takes a username
 * and password and returns a token if the credentials are valid.
 * The token is used for subsequent requests to prove the user is
 * authenticated.
 * 
 * @param {string} username - The user's username
 * @param {string} password - The user's password
 * @returns {string} Authentication token
 */
async function authenticate(username, password) {
  // ...
}
```

**Problems:**
- Explains obvious (authentication needs credentials)
- Repeats function signature (username, password obvious from params)
- No non-obvious WHY explained
- Total: ~200 tokens (4x waste)

#### ✅ BETTER: Let Code Speak

```javascript
/**
 * Authenticate user. Returns token valid for 1h.
 * Throws AuthError if credentials invalid (max 3 attempts/minute).
 */
async function authenticate(username: string, password: string): Promise<string>
```

**Characteristics:**
- Explains non-obvious (1h expiry, rate limit)
- Leverages TypeScript types (no need to document param types)
- Concise
- Total: ~50 tokens

---

## Variable & Function Naming

### The Goldilocks Principle

**Too Short:** `a`, `b`, `fn`, `tmp`  
**Too Long:** `userAuthenticationServiceWithTokenValidationAndRefresh`  
**Just Right:** `authService`, `validateToken`, `refreshAuth`

### Naming Guidelines

| Context | Length | Example |
|---------|--------|---------|
| Loop variables | 1-2 chars | `i`, `j`, `id` |
| Local variables | 1-2 words | `user`, `token`, `isValid` |
| Function names | 2-3 words | `validateUser`, `refreshToken` |
| Class names | 2-3 words | `AuthService`, `TokenManager` |
| Avoid | 4+ words | ❌ `UserAuthenticationServiceFactory` |

### Examples

#### ✅ GOOD: Balanced Clarity

```javascript
function validateToken(token, options = {}) {
  const expiryTime = options.expiry || 3600;
  const isExpired = checkExpiry(token, expiryTime);
  return !isExpired;
}
```

**Token count:** ~40 tokens

#### ❌ BAD: Over-Verbose

```javascript
function validateAuthenticationTokenWithExpiryCheck(
  authenticationToken,
  optionalConfigurationOptions = {}
) {
  const tokenExpiryTimeInSeconds = 
    optionalConfigurationOptions.expiryTimeInSeconds || 3600;
  const isAuthenticationTokenExpired = 
    checkIfTokenIsExpired(authenticationToken, tokenExpiryTimeInSeconds);
  return !isAuthenticationTokenExpired;
}
```

**Token count:** ~80 tokens (2x waste)

#### ✅ GOOD: TypeScript Leverage

```typescript
interface TokenOptions {
  expiry?: number;
  issuer?: string;
}

function validateToken(token: string, options: TokenOptions = {}): boolean {
  // Types document themselves, no verbose names needed
  const expiry = options.expiry ?? 3600;
  return !checkExpiry(token, expiry);
}
```

**Token count:** ~50 tokens (includes type definitions)

---

## Test Verbosity

### Testing Philosophy

**Tests should be readable but concise. Avoid essay-length descriptions.**

### Test Description Guidelines

#### ✅ GOOD: Concise Test Descriptions

```javascript
describe('AuthService', () => {
  it('validates token', async () => {
    const valid = await auth.validate(mockToken);
    expect(valid).toBe(true);
  });

  it('rejects expired token', async () => {
    const expired = await auth.validate(expiredToken);
    expect(expired).toBe(false);
  });

  it('refreshes token before expiry', async () => {
    const refreshed = await auth.refresh(almostExpiredToken);
    expect(refreshed.expiry).toBeGreaterThan(Date.now());
  });
});
```

**Token count:** ~120 tokens for 3 tests

#### ❌ BAD: Verbose Test Descriptions

```javascript
describe('Authentication Service with Token Management', () => {
  it('should successfully validate an authentication token when provided with a valid token that has not expired', async () => {
    const result = await authenticationService.validateAuthenticationToken(mockValidToken);
    expect(result).toBe(true);
  });

  it('should return false when attempting to validate an authentication token that has expired beyond the configured expiry time', async () => {
    const result = await authenticationService.validateAuthenticationToken(mockExpiredToken);
    expect(result).toBe(false);
  });

  it('should automatically refresh an authentication token when it is about to expire within the configured threshold time', async () => {
    const result = await authenticationService.refreshAuthenticationToken(mockAlmostExpiredToken);
    expect(result.expiryTime).toBeGreaterThan(Date.now());
  });
});
```

**Token count:** ~240 tokens (2x waste)

### Assertion Messages

**When to add messages:**
- Complex assertions
- Non-obvious failures
- Debugging-critical points

**When to skip messages:**
- Simple assertions (obvious from code)
- Self-documenting tests

```javascript
// ✅ GOOD: Message adds value
expect(token.expiry).toBeGreaterThan(
  Date.now(),
  'Token should not be expired after refresh'
);

// ❌ BAD: Message restates obvious
expect(valid).toBe(true, 'valid should be true');
```

---

## File Splitting Strategies

### When to Split

**Triggers:**
- Approaching 400 lines (proactive split)
- Multiple responsibilities (SRP violation)
- Difficult to navigate
- Rarely need full file context

### How to Split

#### Strategy 1: By Feature

```
# Before (800 lines)
auth-service.js

# After
auth/
├── service.js (200 lines - orchestration)
├── validation.js (180 lines)
├── tokens.js (220 lines)
└── refresh.js (150 lines)
```

#### Strategy 2: By Layer (Progressive Disclosure)

```
# Before (1200 lines)
database-queries.js

# After
database/
├── index.js (100 lines - exports + high-level)
├── users.js (350 lines)
├── products.js (420 lines)
└── orders.js (280 lines)
```

#### Strategy 3: By Abstraction Level

```
# Before (900 lines)
api-client.js

# After
api/
├── client.js (150 lines - public API)
├── internals/
│   ├── request.js (250 lines)
│   ├── response.js (220 lines)
│   └── errors.js (180 lines)
```

---

## Lazy Loading Protocol

### Core Principle

**Load only what's needed, when it's needed. Never preload "just in case."**

### Implementation Patterns

#### ✅ GOOD: Lazy Import

```javascript
// Only load when function called
async function processImage(file) {
  const sharp = await import('sharp');
  return sharp(file).resize(800, 600).toBuffer();
}
```

#### ❌ BAD: Eager Import

```javascript
// Loaded even if never used
import sharp from 'sharp';

function processImage(file) {
  return sharp(file).resize(800, 600).toBuffer();
}
```

### Skill Loading

```javascript
// Skill manager: Load skills on-demand
class SkillManager {
  async activateSkill(name) {
    // Lazy load skill definition
    const skill = await import(`./skills/${name}/SKILL.md`);
    
    // Only load resources if needed
    if (needsResources(skill)) {
      await this.loadResources(name);
    }
    
    return skill;
  }
}
```

---

## Token Cost Analysis

### Measuring Impact

**Before Context Efficiency Rules:**
```
Typical project context:
- Monolithic files: 5 × 1500 lines = 7500 lines
- Verbose comments: +30% = 9750 lines
- Verbose tests: +20% = 11,700 lines
- Est. tokens: ~35,000 tokens
```

**After Context Efficiency Rules:**
```
Optimized project context:
- Modular files: 20 × 400 lines = 8000 lines (but only load 3-5)
- Concise comments: -30% = 5,600 lines
- Concise tests: -20% = 4,480 lines
- Progressive disclosure: Load only 3 modules = 1,200 lines active
- Est. tokens: ~4,000 tokens
```

**Savings:** ~31,000 tokens per context load  
**Annual Impact (100 sessions):** 3.1M tokens ≈ $62 saved

---

## Enforcement Guidelines

### For AI Assistants

**Before generating any file:**

1. **Check line count projection**
   - Will this be < 500 lines?
   - If no, plan split immediately

2. **Check comment verbosity**
   - Am I explaining WHY or restating WHAT?
   - Can I cut this to 1 line?

3. **Check naming**
   - Are variable names 2-3 words max?
   - Can TypeScript types replace verbose names?

4. **Lazy load check**
   - Do I need to import this now?
   - Can it wait until function call?

**Alert User When:**
```
⚠️ CONTEXT EFFICIENCY ALERT

I'm about to create a file that violates context efficiency:

File: src/services/auth.js
Projected size: 750 lines (exceeds 500-line rule)

Recommendation:
Split into:
- auth/service.js (200 lines - orchestration)
- auth/validation.js (280 lines)
- auth/tokens.js (270 lines)

Proceed with split? (Y/n)
```

### For Developers

**Daily Audit:**
```bash
# Check for violations
find src -name "*.js" -o -name "*.ts" | \
  xargs wc -l | \
  awk '$1 > 500 {print "⚠️", $1, $2}'
```

**Pre-commit Hook:**
```bash
#!/bin/bash
# Warn on files > 500 lines
violations=$(find src -name "*.js" -o -name "*.ts" | xargs wc -l | awk '$1 > 500 {print $2}')

if [ -n "$violations" ]; then
  echo "⚠️ Context Efficiency Warning:"
  echo "$violations"
  echo "Consider splitting files over 500 lines"
fi
```

---

## Integration with Other Rules

### With Documentation Economy

**Scenario:** Creating implementation notes

**Documentation Economy:** "Temporary notes OK with expiration"  
**Context Efficiency:** "Keep notes < 500 lines, split if larger"

**Combined Result:**
```markdown
---
file_class: ephemeral
expires_after_days: 30
---

# Migration Notes (Part 1 of 2)

[Content < 500 lines]
```

### With File Lifecycle

**Scenario:** Skill file growing

**File Lifecycle:** "Classify as PERMANENT"  
**Context Efficiency:** "Split at 500 lines"

**Combined Result:**
- Split skill into SKILL.md (< 500) + resources/ (< 500 each)
- All parts marked PERMANENT
- Progressive disclosure maintained

---

## Summary: Context Efficiency Rules

### The Core Rules

1. **500-Line Limit** - All files < 500 lines (exceptions justified)
2. **Progressive Disclosure** - Load metadata first, details on-demand
3. **Concise Comments** - Explain WHY in 1 line, not WHAT in paragraphs
4. **Balanced Naming** - 2-3 words, leverage types
5. **Terse Tests** - Readable but concise descriptions
6. **Lazy Loading** - Import only when needed
7. **Proactive Splitting** - Split at 400 lines, not 600

### Quick Decision Guide

| Question | Guideline |
|----------|-----------|
| File approaching 500 lines? | Split now using progressive disclosure |
| Comment > 3 lines? | Trim to 1-2 lines explaining WHY |
| Variable name > 3 words? | Shorten, leverage TypeScript types |
| Test description essay-length? | Cut to key point only |
| Importing unused module? | Lazy load on-demand |
| Loading full skill file? | Load SKILL.md, resources on-demand |

---

**Rule Version:** 1.0.0  
**Created:** November 14, 2025  
**Last Updated:** November 14, 2025  
**Applies To:** All diet103 projects  
**Formalizes:** diet103's 500-line rule + token efficiency principles

**Next Review:** December 14, 2025

---

*"Code is read more than written. Comments are read more than code. Choose every token wisely."*

